#version 460
#extension GL_GOOGLE_include_directive : enable // Include files
#extension GL_EXT_ray_tracing : enable // Raytracing

// Include structs and bindings
#include "rt_common/bindpoints.glsl"// Defines constants for the bind indices that RaytracingStage uses
#include "common/camera.glsl"// Binds camera matrices UBO
#include "rt_common/tlas.glsl"// Binds Top Level Acceleration Structure
#include "common/xteanoise.glsl"
#include "common/lcrng.glsl"
#include "shading/constants.glsl"

#define BIND_SIMPLIFIEDLIGHTARRAY 11
#include "rt_common/simplifiedlights.glsl"

#include "../visitest/visitest.glsl"
const VisiTestConfig visiTestConfig = { 0, 0, 0 };

#define BIND_OUT_IRRADIANCE_CACHE BIND_OUT_IMAGE
#include "../irradiancecache/irradiancecache.glsl"

const bool DEBUG_PATTERN = false;
const uint DEBUG_PATTERN_GRADIANTS = 10;

// Do a maximum of 5 light tests (since each is a ray cast, which is quite expensive)
const uint DIRECT_LIGHT_TEST_CNT = 5;

vec3 CollectDirectLight(vec3 pos, uint seed)
{
	const uint lightTestCount = min(DIRECT_LIGHT_TEST_CNT, SimplifiedLights.Count);

	vec3 directLightSum = vec3(0);
	int directLightWeight = 0;

	for (uint i = 0; i < lightTestCount; i++)
	{
		// Randomly select a light source
		lcgUint(seed);
		SimplifiedLight light = SimplifiedLights.Array[seed % SimplifiedLights.Count];

		// light properties
		vec3 origin = pos;
		vec3 dir = vec3(0);
		float len = 0;
		float dropoffFactor = 1;
		if (light.Type == SimplifiedLightType_Directional)
		{
			dir = normalize(light.PosOrDir);
			len = INFINITY;
		}
		else
		{
			dir = light.PosOrDir - origin;
			len = length(dir);
			dir = normalize(dir);
			dropoffFactor = 1 / (len * len);
		}

		// If light source is visible ...
		if (!performVisiTest(visiTestConfig, origin, 0.001, dir, len))
		{
			directLightSum += (light.Intensity * light.Color) / (4 * PI) * dropoffFactor;
			directLightWeight += 1;
		}
	}

	return directLightWeight > 0 ? directLightSum / directLightWeight : vec3(0);
}

void main()
{
	const uvec3 originIrrPixel = gl_LaunchIDEXT.xyz;
	const vec3 origin = transformIrradiancePixelToWorld(originIrrPixel);
	uint seed = CalculateSeedXTEA(originIrrPixel, TracerConfig.RngSeed);

	vec3 irradiance = CollectDirectLight(origin, seed);

	if (DEBUG_PATTERN) {
		const uint levels = DEBUG_PATTERN_GRADIANTS;
		irradiance += vec3(float((originIrrPixel.x + originIrrPixel.y + originIrrPixel.z) % levels) / levels);
	}
	writeIrradianceCache(originIrrPixel, vec4(irradiance, 0.0));
}
